package log

import (
	"context"
	"fmt"
	"os"

	"github.com/minhthong582000/soa-404/pkg/config"
	"github.com/minhthong582000/soa-404/pkg/context_keys"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"go.uber.org/zap/zaptest/observer"
)

var loggerLevelMap = map[string]zapcore.Level{
	"debug":  zapcore.DebugLevel,
	"info":   zapcore.InfoLevel,
	"warn":   zapcore.WarnLevel,
	"error":  zapcore.ErrorLevel,
	"dpanic": zapcore.DPanicLevel,
	"panic":  zapcore.PanicLevel,
	"fatal":  zapcore.FatalLevel,
}

// ILogger is a logger that supports log levels, context and structured logging.
type ILogger interface {
	// With returns a logger based off the root logger and decorates it with the given context and arguments.
	With(ctx context.Context, args ...interface{}) ILogger
	// Debug uses fmt.Sprint to construct and log a message at DEBUG level
	Debug(args ...interface{})
	// Info uses fmt.Sprint to construct and log a message at INFO level
	Info(args ...interface{})
	// Error uses fmt.Sprint to construct and log a message at ERROR level
	Error(args ...interface{})
	// Debugf uses fmt.Sprintf to construct and log a message at DEBUG level
	Debugf(format string, args ...interface{})
	// Infof uses fmt.Sprintf to construct and log a message at INFO level
	Infof(format string, args ...interface{})
	// Errorf uses fmt.Sprintf to construct and log a message at ERROR level
	Errorf(format string, args ...interface{})
}

type logger struct {
	*zap.SugaredLogger
}

// New creates a new logger using the default configuration.
func New(config config.Logs) *logger {
	// Get the log level from the config
	level, exist := loggerLevelMap[config.Level]
	if !exist {
		level = zapcore.DebugLevel
	}

	outputPaths := []string{"stderr"}
	if config.Path != "" {
		// Create the directory if it doesn't exist
		if _, err := os.Stat(config.Path); os.IsNotExist(err) {
			err := os.MkdirAll(config.Path, 0755)
			if err != nil {
				panic(fmt.Sprintf("Failed to create log directory: %v", err))
			}
		}

		// Create the file output
		file, err := os.Create(fmt.Sprintf("%s/%s.log", config.Path, "app"))
		if err != nil {
			panic(fmt.Sprintf("Failed to create log file: %v", err))
		}
		outputPaths = append(outputPaths, file.Name())
	}

	// Define the logging configuration
	zapConfig := zap.Config{
		Encoding:         "json",
		Level:            zap.NewAtomicLevelAt(level),
		Development:      config.Development,
		OutputPaths:      outputPaths,
		ErrorOutputPaths: outputPaths,
		EncoderConfig: zapcore.EncoderConfig{
			TimeKey:        "ts",
			LevelKey:       "level",
			NameKey:        "logger",
			CallerKey:      "caller",
			FunctionKey:    zapcore.OmitKey,
			MessageKey:     "msg",
			StacktraceKey:  "stacktrace",
			LineEnding:     zapcore.DefaultLineEnding,
			EncodeLevel:    zapcore.LowercaseLevelEncoder,
			EncodeTime:     zapcore.EpochTimeEncoder,
			EncodeDuration: zapcore.SecondsDurationEncoder,
			EncodeCaller:   zapcore.ShortCallerEncoder,
		},
	}

	l, err := zapConfig.Build(zap.AddCaller(), zap.AddCallerSkip(1))
	if err != nil {
		panic(fmt.Sprintf("Failed to create logger: %v", err))
	}

	return NewWithZap(l)
}

// NewWithZap creates a new logger using the preconfigured zap logger.
func NewWithZap(l *zap.Logger) *logger {
	return &logger{l.Sugar()}
}

// NewForTest returns a new logger and the corresponding observed logs which can be used in unit tests to verify log entries.
func NewForTest() (ILogger, *observer.ObservedLogs) {
	core, recorded := observer.New(zapcore.InfoLevel)
	return NewWithZap(zap.New(core)), recorded
}

// With returns a logger based off the root logger and decorates it with the given context and arguments.
//
// If the context contains request ID and/or correlation ID information (recorded via WithRequestID()
// and WithCorrelationID()), they will be added to every log message generated by the new logger.
//
// The arguments should be specified as a sequence of name, value pairs with names being strings.
// The arguments will also be added to every log message generated by the logger.
func (l *logger) With(ctx context.Context, args ...interface{}) ILogger {
	if ctx != nil {
		if id, ok := ctx.Value(context_keys.RequestIDKey).(string); ok {
			args = append(args, zap.String("request_id", id))
		}
		if id, ok := ctx.Value(context_keys.CorrelationIDKey).(string); ok {
			args = append(args, zap.String("correlation_id", id))
		}
	}

	span := trace.SpanFromContext(ctx)
	if span != nil {
		args = append(args, zap.String("trace_id", span.SpanContext().TraceID().String()))
		args = append(args, zap.String("span_id", span.SpanContext().SpanID().String()))
	}
	if len(args) > 0 {
		return &logger{l.SugaredLogger.With(args...)}
	}

	return l
}
